/*	@file main.c 
 *	@brief main file for stream benchmark using iocomp
 *
 *	@author Shrey (sb15895) 
 */ 
#include <stdbool.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include "mpi.h"
#include "stream.h"


int main(int argc, char** argv)
{

	int ierr;
	ierr = MPI_Init(&argc, &argv);  
	mpi_error_check(ierr); 

	/* 
	 * initialise structs 
	 */ 
	struct stream_params streamParams; 
	struct iocomp_params iocompParams; 

	MPI_Comm comm = MPI_COMM_WORLD; 
	int rank; 
	int size; 
	MPI_Comm_rank(comm, &rank); 
	MPI_Comm_size(comm, &size); 

	/*	
	 * initialise stream param structs using command line parameters
	 */
	commandLineArgs(&streamParams, rank, argc, argv); 
	//streamParams.nx*=(size+1); // test for different local sizes 
	//streamParams.ny*=(size+10); // test for different local sizes 	
	if(!rank){
		printf("STREAM benchmark starts with size %i \n", size);
		if (streamParams.HT_flag)
		{
			puts("HT flag is set to on");
			printf("size of array %i x %i IO num %i \n", streamParams.nx, streamParams.ny, streamParams.io); 
		} 
		else if (streamParams.sharedFlag)
		{
			puts("Shared flag is set to on");
			printf("size of array %i x %i IO num %i \n", streamParams.nx, streamParams.ny, streamParams.io); 
		} 
		else 
		{
			puts("HT flag is switched off"); 
			printf("size of array %i x %i IO num %i \n", streamParams.nx, streamParams.ny, streamParams.io); 
		} 
	} 

	/*
	 * iocomp - iocompInit initialises the ioServer 
	 * and initialises the compute comm 
	 */ 
	MPI_Comm computeComm = iocompInit(&iocompParams,comm, streamParams.HT_flag, streamParams.io, NODESIZE, streamParams.sharedFlag, NUMWIN); 
	if(streamParams.verboseFlag){
		fprintf(streamParams.debug,"stream->after iocompinit \n");
	} 

	int computeRank;
	MPI_Comm_rank(computeComm, &computeRank); 

	/*
	 * initialises the local array sizes 
	 * multiplying by size1 x size2
	 */ 
	streamParams.localDataSize = streamParams.nx*streamParams.ny;  
	if(streamParams.verboseFlag){
		fprintf(streamParams.debug,"stream-> localdatasize initialised with %li \n", streamParams.localDataSize);
	}

	computeStep(&iocompParams, &streamParams, computeComm); // do compute 
	if(streamParams.verboseFlag){
		fprintf(streamParams.debug,"stream-> after computeStep \n");
	}

	/*
	 * Verify output generated by STREAM by reading in the file, checking each
	 * entry in the array with the expected outcome from STREAM
	 */ 
	if(streamParams.verboseFlag){
		fprintf(streamParams.debug,"stream-> after verification\n");
	}

	/*  
	 * if HT flag is on, then 0 of compute rank 
	 * writes results to csv file 
	 * else if HT flag is off, then 0 of global rank 
	 * writes results to csv file 
	 * reduce results across computeComm and get max timers
	 */ 
	reduceResults(&streamParams, computeComm); 

	if(computeRank == 0)
	{
		resultsOutput(&streamParams, computeComm); // output avg timers to csv file 
		fullResultsOutput(&streamParams); // output all timers to csv files
	}   

	if(streamParams.verboseFlag){
		fprintf(streamParams.debug,"stream->Before MPI finalize rank \n");
	}
	ierr = MPI_Finalize(); 
	mpi_error_check(ierr); 
	if(streamParams.verboseFlag){
		fprintf(streamParams.debug,"stream->MPI finalize\n");
	}

	return 0; 

} 

